<!DOCTYPE html>
<html> 
    <head>
        <title>Simple 3D to 2D projection</title>
        <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    </head>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; }
        #render { position: absolute; }
    </style>
    <body>
        <canvas id="render"></canvas>
    </body>
    <script src="draw.js"></script>
    <script src="control.js"></script>
    <script src="math.js"></script>
    <script src="vec.js"></script>
    <script src="camera.js"></script>
    <script src="mesh.js"></script>
    <script>

        // Settings for the rendering.
        var rendering = true, 
            fps = 30,
            refreshRate = 1000/fps,
            currentFrame = 0,
            fov = Math.min(innerWidth,innerHeight),
            camera = new Camera(fov),
            verbose = false,
            cameraMoveSpeed = 0.1,
            mouseSensitivity = 500,
            fontFamily = "Orbitron",
            meshes = [];

        // Set an initial position for the camera.
        //camera.position = new Vec3(-5.91, -4.1, -7.84);
        //camera.rotation = new Vec2(-0.62, -0.43);

        // Handles movement with the mouse.
        var mouseCallback = function(e) {
            registerMouseCallback(); // Register and deregisters the mousemove
                                     // event when the pointer lock changes.
            var movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
            var movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
            camera.rotation.x -= movementX / mouseSensitivity;
            camera.rotation.y -= movementY / mouseSensitivity;
            if(verbose) console.log(e);
        }

        // Handles the movement with the keyboard.
        var keydownCallback = function(e) {

            // Determine the correct (x,y) movement (applies camera rotation).
            var x = cameraMoveSpeed * Math.sin(camera.rotation.x),
                y = cameraMoveSpeed * Math.cos(camera.rotation.x);

            switch(e.keyCode) {
                case 87: case 38: camera.position.x -= x; camera.position.z += y;     break; // Forward
                case 83: case 40: camera.position.x += x; camera.position.z -= y;     break; // Backward
                case 65: case 37: camera.position.x -= y; camera.position.z -= x;     break; // Right
                case 68: case 39: camera.position.x += y; camera.position.z += x;     break; // Left
                case 81:          camera.position.y -= cameraMoveSpeed;               break; // Up
                case 69:          camera.position.y += cameraMoveSpeed;               break; // Down
                default: if(verbose) console.log("Key pressed: " + e.key + " (" + e.keyCode + ")"); break;
            }
        }

        // Create two cubes and a floor.
        meshes.push(generateCubeMesh());
        meshes.push(generateCubeMesh());
        meshes.push(generateCubeMesh());
        var cube1 = meshes[0], cube2 = meshes[1], floor = meshes[2];

        // Move the cubes.
        cube1.translate(new Vec3(2,0,0));
        cube2.translate(new Vec3(-2,0,0));

        // Create the floor.
        for(var i=0; i < floor.faces.length; i++) {
            floor.faces[i].color = CL_GRAY;
        }
        floor.vmult(new Vec3(3, 0.02, 3));
        floor.translate(new Vec3(0,3,0));

        // Main render loop.
        var render = function() {
            clear();

            // Rotate the cubes as animation. First we need to translate
            // the cube back to the origin (0,0,0), then rotate, and translate
            // back to the position.
            cube1.translate(new Vec3(-2,0,0));
            cube2.translate(new Vec3(2,0,0));
            cube1.rotateY(1/(8*Math.PI));
            cube2.rotateY(-1/(16*Math.PI));
            cube1.translate(new Vec3(2,0,0));
            cube2.translate(new Vec3(-2,0,0));

            // Fill the depth buffer with all the faces from all the meshes.
            depthBuffer = [];
            for(var i=0; i < meshes.length; i++) {
                mesh = meshes[i];
                // Calculate the distance of a face to the camera, and add it to a depth buffer.
                for(var j=0; j < mesh.faces.length; j++) {
                    // Find the vertex in the center of the face and calculate the distance
                    // of this vertex to the camera.
                    distance = camera.position.distance(mesh.faces[j].average(mesh.vertices));
                    depthBuffer.push({mesh: i, face: j, distance: distance});
                }
            }

            // Sort the depth buffer on distance, we want to draw the furthest face first.
            depthBuffer.sort(function(a, b) { return b.distance - a.distance });

            // Draw all the faces in the depth buffer.
            for(var i=0; i < depthBuffer.length; i++) {
                mesh = meshes[depthBuffer[i].mesh];
                face = mesh.faces[depthBuffer[i].face];
                // Find all the points in the face and draw a polygon.
                points = [];
                for(j=0; j < face.vertices.length; j++) {
                    v = mesh.vertices[face.vertices[j]];
                    transformed = transform(v, camera);
                    points.push({x: transformed.x, y: transformed.y});
                }
                color(face.color);
                polygon(points);
            }
            
            // Post-render
            font("16px " + fontFamily);
            color(CL_WHITE);
            uitext(10,25,"FPS: " + fps + ", FOV: " + fov);
            uitext(10,45,"Current frame: " + currentFrame);
            uitext(10,65,"Camera position: " + camera.position.toString());
            uitext(10,85,"Camera rotation: " + camera.rotation.toString());
            uitext(10,innerHeight-15,"You can move with W, A, S, D, and go up/down with Q, E.");

            currentFrame++;
            if(rendering) {
                setTimeout(render, refreshRate);
            }
        }

        // Initialize the canvas and events.
        ctx = initCanvasContext("render");
        center(); // (0,0) should be the screen center.
        bindKeydown(keydownCallback);
        bindClick(pointerLockCallback); // Create a pointer lock on click
        bindMouse(mouseCallback); // Mouse movement callback
        render();
    </script>
</html>
